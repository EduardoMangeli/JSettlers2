/**
 * Java Settlers - An online multiplayer version of the game Settlers of Catan
 * This file Copyright (C) 2017 Jeremy D Monin <jeremy@nand.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The maintainer of this program can be reached at jsettlers@nand.net
 */

syntax = "proto3";

option java_package = "soc.proto";
option optimize_for = SPEED;  // json needs proto metadata, can't use smaller/cleaner LITE_RUNTIME

import public "data.proto";


// Messages during play of a specific game, dispatched at server by a GameMessageHandler.
//
// GameMessages are grouped by category. See the bottom of this file
// for GameMessageFromServer and FromClient, which use OneOf union groups.
// Those main GameMessage types are themselves sent as a OneOf field
// of the main Message.FromServer and Message.FromClient types.
//


//
// Board Layout and Contents
//

/* Board layout contents.
 * Sent when game starts or client joins a game in progress.
 * TODO: Further docs on encoding_format, ref to list of part keynames, etc
 */
message BoardLayout
{
    message _BoardLayoutPart {
        message IntArray { repeated int32 arr = 1; }  // since oneof can't directly contain a repeated field (array)

        oneof val {
            int32 i_val = 1;    // signed integer value
            string s_val = 2;   // string value
            IntArray i_arr = 3;  // signed integer array
        }
    }

    uint32 encoding_format = 1;  // Board layout encoding version, from {@link SOCBoard#getBoardEncodingFormat()}
    map<string, _BoardLayoutPart> parts = 2;  // Layout Parts; some are optional depending on game options and scenario
}


//
// Game and Player State
//

/* The current state of the game, sent when it changes.
 *<P>
 * Messages which change the current turn or player, like {@link Turn}
 * and {@link StartGame}, include the new turn's state as a field because
 * the current player and game state are both changing.
 *<P>
 * For some states, such as {@link Data.GameState#WAITING_FOR_ROB_CHOOSE_PLAYER},
 * another message (such as {@link ChoosePlayerRequest}) will
 * follow to prompt the current player.  For others, such as
 * {@link Data.GameState#WAITING_FOR_DISCOVERY} or
 * {@link Data.GameState#WAITING_FOR_ROBBER_OR_PIRATE}, sending this
 * State message implies that the player must decide and respond.
 *<P>
 * For {@link Data.GameState#WAITING_FOR_ROBBER_OR_PIRATE}, the player should
 * respond with {@link ChoosePlayer}; see that message's javadoc.
 *<P>
 * Before v3.0.00 this message was {@code GameState}.
 */
message State {
    GameState state = 1;
}

/* Action type for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementAction {
    _UNSENT_DEFAULT_ACTION = 0;  // Required for enum, but not sent: not a valid action type
    SET  = 1;  // Set element to value
    GAIN = 2;  // Add value to element
    LOSE = 3;  // Subtract value from element
}

/* Player element type for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementType {
    /* Required for enum, but not sent: not a valid player element */
    _UNSENT_DEFAULT_ELEM = 0;

    /*
     * player element types (1-5). CLAY has same value
     * as {@link Data.ResourceType#CLAY_VALUE};
     * ORE, SHEEP, WHEAT and WOOD also match Data.ResourceType.
     * and {@code SOCResourceConstants}.
     */
    ELEM_CLAY = 1;
    ELEM_ORE = 2;
    ELEM_SHEEP = 3;
    ELEM_WHEAT = 4;
    ELEM_WOOD = 5;

    /*
     * Amount of resources of unknown type; sent in messages about opponents' resources.
     * For some loops which send resource types + unknown, this constant is assumed to be 6
     * (5 known resource types + 1).
     */
    ELEM_UNKNOWN_RESOURCE = 6;

    /* Number of Road pieces available to place. */
    ROADS = 10;

    /* Number of Settlement pieces available to place. */
    SETTLEMENTS = 11;

    /* Number of City pieces available to place. */
    CITIES = 12;

    /*
     * Number of Ship pieces available to place.
     * @since 2.0.00
     */
    SHIPS = 13;

    /*
     * Number of knights in player's army; sent after a Soldier card is played.
     */
    NUMKNIGHTS = 15;

    /*
     * For the 6-player board, player element type for asking to build
     * during the {@link soc.game.SOCGame#SPECIAL_BUILDING Special Building Phase}.
     * This element is {@code SET} to 1 or 0.
     * @since 1.1.08
     */
    ASK_SPECIAL_BUILD = 16;

    /*
     * For the {@link soc.game.SOCBoardLarge large sea board},
     * player element type for asking to choose
     * resources from the gold hex after a dice roll,
     * during the {@link soc.game.SOCGame#WAITING_FOR_PICK_GOLD_RESOURCE WAITING_FOR_PICK_GOLD_RESOURCE}
     * game state.
     * This element is {@code SET} to 0 or to the number of resources to choose.
     * Call {@link soc.game.SOCPlayer#setNeedToPickGoldHexResources(int)}.
     * @since 2.0.00
     */
    NUM_PICK_GOLD_HEX_RESOURCES = 17;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * the player's number of Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's
     * {@link soc.game.SOCPlayer#getSpecialVP()}.
     * @since 2.0.00
     */
    SCENARIO_SVP = 18;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of flags related to scenario player events.
     * This element is {@code SET} to 0 or to the player's flags
     * from {@link soc.game.SOCPlayer#getScenarioPlayerEvents()}.
     * @since 2.0.00
     */
    SCENARIO_PLAYEREVENTS_BITMASK = 19;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of land areas for tracking Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's land areas
     * from {@link soc.game.SOCPlayer#getScenarioSVPLandAreas()}.
     * @since 2.0.00
     */
    SCENARIO_SVP_LANDAREAS_BITMASK = 20;

    /*
     * Player's starting land area numbers.
     * Sent only at reconnect, because these are also tracked during play at the client.
     * Sent as <tt>(landArea2 &lt;&lt; 8) | landArea1</tt>.
     * @since 2.0.00
     */
    STARTING_LANDAREAS = 21;

    /*
     * For scenario <tt>_SC_CLVI</tt> on the {@link soc.game.SOCBoardLarge large sea board},
     * the number of cloth held by this player.
     * This element is {@code SET} to 0 or to the player's cloth count
     * from {@link soc.game.SOCPlayer#getCloth()}.
     * After giving cloth to a player, check their total VP; 2 cloth = 1 Victory Point.
     *<P>
     * The board's "general supply" is updated with this element type
     * with {@link #getPlayerNumber()} == -1.
     * Each village's cloth count is updated with a {@link SOCPieceValue PIECEVALUE} message.
     * @since 2.0.00
     */
    SCENARIO_CLOTH_COUNT = 22;

    /*
     * For scenario game option <tt>_SC_PIRI</tt>,
     * the player's total number of ships that have been converted to warships.
     * See SOCPlayer.getNumWarships() for details.
     * This element can be {@code SET} or {@code GAIN}ed.  For clarity, if the number of
     * warships decreases, send {@code SET}, never send {@code LOSE}.
     * {@code GAIN} is sent only in response to a player's successful
     * {@link SOCPlayDevCardRequest} to convert a ship to a warship.
     *<P>
     * If a player is joining a game in progress, the <tt>PLAYERELEMENT(SCENARIO_WARSHIP_COUNT)</tt>
     * message is sent to their client only after sending their SOCShip piece positions.
     * @since 2.0.00
     */
    SCENARIO_WARSHIP_COUNT = 23;
}

/*
 * This message from the server conveys one part of a player's status,
 * such as their number of settlements remaining.
 *<P>
 * Unless otherwise mentioned, any {@code elementType} can be sent with
 * any action ({@link _PlayerElementAction#SET}, {@link _PlayerElementAction#GAIN GAIN},
 * {@link _PlayerElementAction#LOSE LOSE}).
 *
 *<H3>Message Sequence:</H3>
 *<UL>
 * <LI> For a bank trade (server response to player's {@link BankTrade}),
 *   all the {@code LOSE} messages come before the {@code GAIN}s.
 * <LI> For trade between players ({@link AcceptOffer}), the {@code LOSE}s and {@code GAIN}s
 *   are interspersed to simplify server code.
 * <LI> Most other situations send single PlayerElement messages or their sequence doesn't matter.
 *</UL>
 *<P>
 * Resource loss can be expected and good (buying pieces or trading with other players)
 * or unexpected and bad (monopoly, robber, discards). v1.2.00 and newer have sound effects
 * to announce unexpected gains or losses; to help recognize this, this message type has a
 * {@link #isNews()} flag field.
 *<P>
 * To use less overhead to send multiple similar element changes, use {@link PlayerElements} instead.
 */
message PlayerElement {
    /* Some element types can use -1 for all players, some others don't use this field.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     */
    sint32 playerNumber = 1;
    _PlayerElementAction action = 2;
    _PlayerElementType elementType = 3;
    sint32 amount = 4;
    bool isNews = 5;
}

/*
 * This message from the server holds information on some parts of a player's status,
 * such as resource type counts.  Same structure as {@link PlayerElement} but with
 * less overhead to send multiple similar element changes.
 *<P>
 * For a given player number and action type, contains parallel lists for sending
 * (element type, amount) pairs.
 *<P>
 * Defined in v1.1.09 but unused before v2.0.00.
 */
message PlayerElements {
    /* Some element types can use -1 for all players, some others don't use this field.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     */
    sint32 playerNumber = 1;
    _PlayerElementAction action = 2;
    repeated _PlayerElementType elementTypes = 3;
    repeated sint32 amounts = 4;
}


//
// Current Turn
//

/* From client, this message means that a player wants to start the game;
 * from server, it means that a game has just started, leaving state {@code NEW}.
 *<P>
 * If a client joins a game in progress it won't be sent a {@code SOCStartGame} message,
 * only the game's current {@code GameState} and other parts of the game's and
 * players' current status.
 */
message StartGame {
    GameState state = 1;  // new state; ignored from client
}

/* End of the current player's turn, start of a new turn.
 * Client should end current turn, clear dice, set current player number, reset votes, etc.
 * New player's client should check the state field to inform that player's options and actions.
 *<P>
 * Sent at game state {@link Data.GameState#OVER} to confirm the winning player,
 * who will already be the current player.
 *<P>
 * Also can be sent to a client joining a game in progress, to set only the current player number.
 * In this case {@code state} will be empty or 0. Before v3.0.00 this usage was a separate
 * {@code SOCSetTurn} message type.
 */
message Turn {
    uint32 player_number = 1;  // new current player's seat number
    GameState state = 2;  // new state, or empty/0 when joining game in progress
}

/* Player wants to end their turn. */
message EndTurn {
    // no detail fields are needed
}


//
// GameMessageFromServer, FromClient: For encode/decode, a GameMessage type
// containing all other message types using OneOf. These main GameMessageFromServer
// and FromClient types are sent as a OneOf in the main Message.FromServer and FromClient.
//


message GameMessageFromServer {
    string ga_name = 1;      // Name of game
    oneof msg {

        // game and player state
        State game_state = 2;
        PlayerElement player_element = 15;
        PlayerElements player_elements = 25;  // above #15; is efficient enough (sets multiple elements) without that saved byte

        // board layout and contents
        BoardLayout board_layout = 30;

        // turn
        StartGame start_game = 100;
        Turn turn = 101;
    }
}

message GameMessageFromClient {
    string ga_name = 1;      // Name of game
    oneof msg {
        // turn
        StartGame start_game = 100;
        EndTurn end_turn = 101;
    }
}
