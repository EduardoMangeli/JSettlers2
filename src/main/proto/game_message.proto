/**
 * Java Settlers - An online multiplayer version of the game Settlers of Catan
 * This file Copyright (C) 2017 Jeremy D Monin <jeremy@nand.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The maintainer of this program can be reached at jsettlers@nand.net
 */

syntax = "proto3";

option java_package = "soc.proto";
option optimize_for = SPEED;  // json needs proto metadata, can't use smaller/cleaner LITE_RUNTIME

import public "data.proto";


// Messages during play of a specific game, dispatched at server by a GameMessageHandler.
//
// GameMessages are grouped by category. See the bottom of this file
// for GameMessageFromServer and FromClient, which use OneOf union groups.
// Those main GameMessage types are themselves sent as a OneOf field
// of the main Message.FromServer and Message.FromClient types.
//


//
// Board Layout and Contents
//

/* Board layout contents.
 * Sent when game starts or client joins a game in progress.
 * TODO: Further docs on encoding_format, ref to list of part keynames, etc
 */
message BoardLayout
{
    message _BoardLayoutPart {
        oneof val {
            int32 i_val = 1;    // signed integer value
            string s_val = 2;   // string value
            _IntArray i_arr = 3;  // signed integer array; negative values allowed but not frequently used
        }
    }

    uint32 encoding_format = 1;  // Board layout encoding version, from {@link SOCBoard#getBoardEncodingFormat()}

    map<string, _BoardLayoutPart> parts = 2;  // Layout Parts; some are optional depending on game options and scenario
}

/* A list of potential settlements, with optional related potential/legal position info.
 * Sent from server when game starts or client joins a game in progress.
 */
message PotentialSettlements {
    /* Player Number this applies to; may be -1 for all players at start of game.
     * -1 also indicates that the legal settlements should be set and the
     * legal roads recalculated from this message's list of potential nodes.
     */
    sint32 player_number = 1;

    /* Potential settlement node coordinates for {@link #playerNumber} */
    repeated int32 ps_nodes = 2;

    /* How many Land Areas this board has; classic boards have 1 */
    uint32 area_count = 3;

    /* Which land area number within {@link #landAreasLegalNodes} contains {@link #psNodes}?
     * 0 if none because the game already started and {@code psNodes} is unique to the player.
     * 0 if none when game is starting now and players can place anywhere.
     *<P>
     * Not used if {@link #areaCount} == 1.
     */
    uint32 starting_land_area = 4;

    /* Each land area's legal node coordinates; keys are 1 to {@link areaCount}.
     * Areas 0 and {@link #startingLandArea} are unused. Not sent if {@code areaCount} == 1.
     */
    map<uint32, _IntArray> land_areas_legal_nodes = 5;

    /* legal sea edges per player for ships, if restricted.
     * Usually not sent, because all sea edges are legal except in scenario _SC_PIRI.
     *<P>
     * If {@link #playerNumber} != -1, {@code legalSeaEdges} contains 1 array, the legal sea edges for that player.
     * Otherwise contains 1 array for each player position (total 4 or 6 arrays).
     *<P>
     * Each per-player array is the same format as in {@code SOCBoardAtServer.PIR_ISL_SEA_EDGES}:
     * A list of individual sea edge coordinates and/or ranges.
     * Ranges are designated by a pair of positive,negative numbers:
     * 0xC04, -0xC0D is a range of the valid edges from C04 through C0D inclusive.
     * If a player position is vacant, their subarray may be empty (length 0) or contain a single zero: <tt>{ 0 }</tt>.
     */
    repeated _SIntArray legal_sea_edges = 6;
}

/* Client player is asking to place, or server is announcing placement of, a piece on the board.
 * Also used when joining a new game or a game in progress, to send the game state so far.
 *<P>
 * If message is for a {@link soc.game.SOCCity} while client is joining a game, must precede with
 * a {@code PutPiece} message with the Settlement at the same coordinate
 * which was upgraded to that city.
 *<P>
 * Some game scenarios use {@link soc.game.SOCVillage villages} which aren't owned by any player;
 * their {@code player_number} is -1 in this message.
 *<P>
 * See also {@link MovePiece}. The messages similar but opposite to this one
 * are {@link CancelBuild} and the very-limited {@link RemovePiece}.
 *<P>
 * Some scenarios like {@link soc.game.SOCScenario#K_SC_PIRI SC_PIRI} include some pieces
 * as part of the initial board layout while the game is starting. These will all be sent to
 * the clients while game state is &lt; {@link soc.game.SOCGame#START1A START1A} and before
 * sending them {@link StartGame}. Scenario {@link soc.game.SOCScenario#K_SC_CLVI SC_CLVI}
 * sends its neutral villages before {@code START1A} but as part {@code "CV"} of the board layout
 * message, not as {@code PutPiece}s.
 */
message PutPiece {
    PieceType type = 1;
    /* the player number who played the piece, or -1 for non-player-owned
     * ({@link soc.game.SOCPlayingPiece#VILLAGE}).
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     * Ignored if sent from client.
     */
    sint32 player_number = 2;
    uint32 coordinates = 3;
}

/* This message from client to server says which piece type the current player wants to build.
 *<P>
 * During game state {@link soc.game.SOCGame#PLAY1 PLAY1}, this is a build request during the player's turn.
 * When sent during other game states, and other players' turns, this is a request
 * to start the 6-player {@link soc.game.SOCGame#SPECIAL_BUILDING Special Building Phase}.
 * @see CancelBuild
 * @see BuyItemRequest
 */
message BuildRequest {
    /* Type of piece to build. When requesting Special Building Phase,
     * this field is optional and its value is ignored.
     */
    PieceType piece_type = 1;
}

/* This message type has five possible meanings, depending on game state and direction sent:
 *<UL>
 *<H3>When sent from client to server:</H3>
 *<LI> During piece placement (PLACING_ROAD, PLACING_SETTLEMENT, PLACING_CITY, PLACING_SHIP, PLACING_INV_ITEM): <BR>
 *   CancelBuild means the player has changed their mind about spending resources to build a piece.
 *   Server will reply by returning the player's resources and changing game state.
 *   <P>
 *   The special inventory items in PLACING_INV_ITEM each have a different placement message, but if item placement
 *   can be canceled, use this common message type, with {@code item_type} == ({@link Data.OtherPlayableItem#INV_ITEM}).
 *   If placement can't be canceled, server will reply with {@link GameServerText}.
 *
 *<LI> While placing the second free road or ship (PLACING_FREE_ROAD2), means
 *   the player has decided to skip placing the second free road or ship,
 *   to use just one road or ship piece.  Server will reply with new game state.
 *   (This was added in v1.1.17)
 *
 *<LI> Not sent from client during other game states. Server will reply with {@link GameServerText}.
 *
 *<H3>When sent from server to a client player:</H3>
 *
 *<LI> During game startup (START1B, START2B or START3B): <BR>
 *   Sent from server, CancelBuild means the current player
 *   is undoing the placement of their initial settlement.
 *
 *<LI> During piece placement (PLACING_ROAD, PLACING_CITY, PLACING_SETTLEMENT,
 *   PLACING_FREE_ROAD1 or PLACING_FREE_ROAD2): <BR>
 *   Sent from server, CancelBuild means the player has sent
 *   an illegal {@link PutPiece} (bad building location). Humans can probably
 *   decide a better place to put their road, but robots must cancel
 *   the build request and decide on a new plan.
 *   <P>
 *   This can also be the reply if the client sends an illegal {@link BuildRequest}
 *   or {@link BuyItemRequest} (no resources, not the right game state, etc.)
 *   or {@link MovePiece}.
 *</UL>
 * Before v3.0.00 this message was {@code SOCCancelBuildRequest}.
 */
message CancelBuild {
    oneof cancel_type {
        PieceType piece_type = 1;
        OtherPlayableItem item_type = 2;
    }
}

/* Client player is asking to move, or server is announcing a move of,
 * a piece on the board to a new location.
 *<H3>From Server:</H3>
 * The client should also print a line of text such as "* Joe moved a ship."
 *<H3>From Client:</H3>
 * The server will reply to all players with {@link MovePiece} if piece can be moved,
 * or reply to the requesting client with {@link CancelBuildRequest}.
 *<P>
 * Before v3.0.00 this message was {@code SOCMovePieceRequest} and {@code SOCMovePiece}.
 * @since 2.0.00
 */
message MovePiece {
    /* Type of playing piece; only {@code SHIP} so far */
    PieceType type = 1;
    /* the player number of who is moving the piece.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     * Ignored if sent from client.
     */
    sint32 player_number = 2;
    uint32 from_coord = 3;
    uint32 to_coord = 4;
}

/* This message from server announces a {@link soc.game.SOCShip} removed from the board.
 * Ships are removed when the player makes an attack on their Pirate Fortress and fails to win.
 * Currently, no other piece types are removed in any scenario, but the message allows for other types
 * in case that changes in a later version.
 *<P>
 * Introduced in v2.0.00 for the pirate islands scenario (_SC_PIRI).
 *
 * @since 2.0.00
 */
message RemovePiece {
    /* Type of playing piece; only {@code SHIP} so far */
    PieceType type = 1;
    /* the player number who owns the piece.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     */
    sint32 player_number = 2;
    uint32 coordinates = 3;
}


//
// Game and Player State
//

/* The current state of the game, sent when it changes.
 *<P>
 * Messages which change the current turn or player, like {@link Turn}
 * and {@link StartGame}, include the new turn's state as a field because
 * the current player and game state are both changing.
 *<P>
 * For some states, such as {@link Data.GameState#WAITING_FOR_ROB_CHOOSE_PLAYER},
 * another message (such as {@link ChoosePlayerRequest}) will
 * follow to prompt the current player.  For others, such as
 * {@link Data.GameState#WAITING_FOR_DISCOVERY} or
 * {@link Data.GameState#WAITING_FOR_ROBBER_OR_PIRATE}, sending this
 * State message implies that the player must decide and respond.
 *<P>
 * For {@link Data.GameState#WAITING_FOR_ROBBER_OR_PIRATE}, the player should
 * respond with {@link ChoosePlayer}; see that message's javadoc.
 *<P>
 * Before v3.0.00 this message was {@code GameState}.
 */
message State {
    GameState state = 1;
}

/* Action type for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementAction {
    _UNSENT_DEFAULT_ACTION = 0;  // Required for enum, but not sent: not a valid action type
    SET  = 1;  // Set element to value
    GAIN = 2;  // Add value to element
    LOSE = 3;  // Subtract value from element
}

/* Player element type for use in PlayerElement and PlayerElements; not sent as a standalone message type */
enum _PlayerElementType {
    /* Required for enum, but not sent: not a valid player element */
    _UNSENT_DEFAULT_ELEM = 0;

    /*
     * player element types (1-5). CLAY has same value
     * as {@link Data.ResourceType#CLAY_VALUE};
     * ORE, SHEEP, WHEAT and WOOD also match Data.ResourceType.
     * and {@code SOCResourceConstants}.
     */
    ELEM_CLAY = 1;
    ELEM_ORE = 2;
    ELEM_SHEEP = 3;
    ELEM_WHEAT = 4;
    ELEM_WOOD = 5;

    /*
     * Amount of resources of unknown type; sent in messages about opponents' resources.
     * For some loops which send resource types + unknown, this constant is assumed to be 6
     * (5 known resource types + 1).
     */
    ELEM_UNKNOWN_RESOURCE = 6;

    /* Number of Road pieces available to place. */
    ROADS = 10;

    /* Number of Settlement pieces available to place. */
    SETTLEMENTS = 11;

    /* Number of City pieces available to place. */
    CITIES = 12;

    /*
     * Number of Ship pieces available to place.
     * @since 2.0.00
     */
    SHIPS = 13;

    /*
     * Number of knights in player's army; sent after a Soldier card is played.
     */
    NUMKNIGHTS = 15;

    /*
     * For the 6-player board, player element type for asking to build
     * during the {@link soc.game.SOCGame#SPECIAL_BUILDING Special Building Phase}.
     * This element is {@code SET} to 1 or 0.
     * @since 1.1.08
     */
    ASK_SPECIAL_BUILD = 16;

    /*
     * For the {@link soc.game.SOCBoardLarge large sea board},
     * player element type for asking to choose
     * resources from the gold hex after a dice roll,
     * during the {@link soc.game.SOCGame#WAITING_FOR_PICK_GOLD_RESOURCE WAITING_FOR_PICK_GOLD_RESOURCE}
     * game state.
     * This element is {@code SET} to 0 or to the number of resources to choose.
     * Call {@link soc.game.SOCPlayer#setNeedToPickGoldHexResources(int)}.
     * @since 2.0.00
     */
    NUM_PICK_GOLD_HEX_RESOURCES = 17;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * the player's number of Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's
     * {@link soc.game.SOCPlayer#getSpecialVP()}.
     * @since 2.0.00
     */
    SCENARIO_SVP = 18;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of flags related to scenario player events.
     * This element is {@code SET} to 0 or to the player's flags
     * from {@link soc.game.SOCPlayer#getScenarioPlayerEvents()}.
     * @since 2.0.00
     */
    SCENARIO_PLAYEREVENTS_BITMASK = 19;

    /*
     * For scenarios on the {@link soc.game.SOCBoardLarge large sea board},
     * bitmask of land areas for tracking Special Victory Points (SVP).
     * This element is {@code SET} to 0 or to the player's land areas
     * from {@link soc.game.SOCPlayer#getScenarioSVPLandAreas()}.
     * @since 2.0.00
     */
    SCENARIO_SVP_LANDAREAS_BITMASK = 20;

    /*
     * Player's starting land area numbers.
     * Sent only at reconnect, because these are also tracked during play at the client.
     * Sent as <tt>(landArea2 &lt;&lt; 8) | landArea1</tt>.
     * @since 2.0.00
     */
    STARTING_LANDAREAS = 21;

    /*
     * For scenario <tt>_SC_CLVI</tt> on the {@link soc.game.SOCBoardLarge large sea board},
     * the number of cloth held by this player.
     * This element is {@code SET} to 0 or to the player's cloth count
     * from {@link soc.game.SOCPlayer#getCloth()}.
     * After giving cloth to a player, check their total VP; 2 cloth = 1 Victory Point.
     *<P>
     * The board's "general supply" is updated with this element type
     * with {@link #getPlayerNumber()} == -1.
     * Each village's cloth count is updated with a {@link SOCPieceValue PIECEVALUE} message.
     * @since 2.0.00
     */
    SCENARIO_CLOTH_COUNT = 22;

    /*
     * For scenario game option <tt>_SC_PIRI</tt>,
     * the player's total number of ships that have been converted to warships.
     * See SOCPlayer.getNumWarships() for details.
     * This element can be {@code SET} or {@code GAIN}ed.  For clarity, if the number of
     * warships decreases, send {@code SET}, never send {@code LOSE}.
     * {@code GAIN} is sent only in response to a player's successful
     * {@link SOCPlayDevCardRequest} to convert a ship to a warship.
     *<P>
     * If a player is joining a game in progress, the <tt>PLAYERELEMENT(SCENARIO_WARSHIP_COUNT)</tt>
     * message is sent to their client only after sending their SOCShip piece positions.
     * @since 2.0.00
     */
    SCENARIO_WARSHIP_COUNT = 23;
}

/*
 * This message from the server conveys one part of a player's status,
 * such as their number of settlements remaining.
 *<P>
 * Unless otherwise mentioned, any {@code elementType} can be sent with
 * any action ({@link _PlayerElementAction#SET}, {@link _PlayerElementAction#GAIN GAIN},
 * {@link _PlayerElementAction#LOSE LOSE}).
 *
 *<H3>Message Sequence:</H3>
 *<UL>
 * <LI> For a bank trade (server response to player's {@link BankTrade}),
 *   all the {@code LOSE} messages come before the {@code GAIN}s.
 * <LI> For trade between players ({@link AcceptOffer}), the {@code LOSE}s and {@code GAIN}s
 *   are interspersed to simplify server code.
 * <LI> Most other situations send single PlayerElement messages or their sequence doesn't matter.
 *</UL>
 *<P>
 * Resource loss can be expected and good (buying pieces or trading with other players)
 * or unexpected and bad (monopoly, robber, discards). v1.2.00 and newer have sound effects
 * to announce unexpected gains or losses; to help recognize this, this message type has a
 * {@link #isNews()} flag field.
 *<P>
 * To use less overhead to send multiple similar element changes, use {@link PlayerElements} instead.
 */
message PlayerElement {
    /* Some element types can use -1 for all players, some others don't use this field.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     */
    sint32 playerNumber = 1;
    _PlayerElementAction action = 2;
    _PlayerElementType elementType = 3;
    sint32 amount = 4;
    bool isNews = 5;
}

/*
 * This message from the server holds information on some parts of a player's status,
 * such as resource type counts.  Same structure as {@link PlayerElement} but with
 * less overhead to send multiple similar element changes.
 *<P>
 * For a given player number and action type, contains parallel lists for sending
 * (element type, amount) pairs.
 *<P>
 * Defined in v1.1.09 but unused before v2.0.00.
 */
message PlayerElements {
    /* Some element types can use -1 for all players, some others don't use this field.
     * Remember that for playerNumber 0, protobuf won't send the field (== default).
     */
    sint32 playerNumber = 1;
    _PlayerElementAction action = 2;
    repeated _PlayerElementType elementTypes = 3;
    repeated sint32 amounts = 4;
}


//
// Current Turn
//

/* From client, this message means that a player wants to start the game;
 * from server, it means that a game has just started, leaving state {@code NEW}.
 *<P>
 * If a client joins a game in progress it won't be sent a {@code SOCStartGame} message,
 * only the game's current {@code GameState} and other parts of the game's and
 * players' current status.
 */
message StartGame {
    GameState state = 1;  // new state; ignored from client
}

/* End of the current player's turn, start of a new turn.
 * Client should end current turn, clear dice, set current player number, reset votes, etc.
 * New player's client should check the state field to inform that player's options and actions.
 *<P>
 * Sent at game state {@link Data.GameState#OVER} to confirm the winning player,
 * who will already be the current player.
 *<P>
 * Also can be sent to a client joining a game in progress, to set only the current player number.
 * In this case {@code state} will be empty or 0. Before v3.0.00 this usage was a separate
 * {@code SOCSetTurn} message type.
 */
message Turn {
    uint32 player_number = 1;  // new current player's seat number
    GameState state = 2;  // new state, or empty/0 when joining game in progress
}

/* This message from server to client says whose turn it is.
 * Only the game's current player number should change; no other
 * game state is updated.
 */
message SetTurn {
    uint32 player_number = 1;  // new current player's seat number
}

/* Reports the total of what was rolled on the dice this turn.
 * The two individual dice amounts can be reported in a text message.
 *<P>
 * This is in response to a client player's {@link RollDice} request.
 * Will always be followed by {@link State} (7 might lead to discards
 * or moving the robber, etc.), and sometimes with further messages after that,
 * depending on the roll results and scenario/rules in effect.
 *<P>
 * When players gain resources on the roll, game members will be sent {@link DiceResultResources}.
 *<P>
 * Players who gain resources on the roll will be sent
 * {@link PlayerElement PlayerElement(SET, resType, amount)} messages
 * for all their new resource counts.  Before v2.0.00, those were sent to each
 * player in the game after a roll, not just those who gained resources.
 * Afterwards each gaining player (any client version) is sent their currently
 * held amounts for each resource as a group of <tt>PlayerElement(pn, {@link #SET}, ...)</tt>
 * messages. Then, for each player who gained resources, their total {@link ResourceCount}
 * is sent to the game. */
message DiceResult {
    uint32 dice_total = 1;  // total rolled on both dice
}

/* All resources gained by players from a dice roll.
 * Sent to all game members after a {@link DiceResult}.
 */
message DiceResultResources {
    /* One player's gained resource types and amounts.
     * Uses parallel lists to simplify nested message structure.
     */
    message PlayerResources {
        uint32 player_number = 1;
        /* Type of each resource gained; same length as res_amount */
        repeated ResourceType res_type = 2;
        /* Amount of each resource type gained; same length as res_type */
        repeated uint32 res_amount = 3;
    }
    repeated PlayerResources player_resources = 1;
}

/* Player wants to end their turn. */
message EndTurn {
    // no detail fields are needed
}


//
// Player Info
//


//
// Player Actions
//


//
// GameMessageFromServer, FromClient: For encode/decode, a GameMessage type
// containing all other message types using OneOf. These main GameMessageFromServer
// and FromClient types are sent as a OneOf in the main Message.FromServer and FromClient.
//


message GameMessageFromServer {
    string ga_name = 1;      // Name of game
    oneof msg {

        // game and player state
        State game_state = 2;
        PlayerElement player_element = 15;
        PlayerElements player_elements = 25;  // above #15; is efficient enough (sets multiple elements) without that saved byte

        // board layout and contents
        BoardLayout board_layout = 30;
        PotentialSettlements potential_settlements = 31;
        PutPiece put_piece = 32;
        CancelBuild cancel_build = 33;
        MovePiece move_piece = 34;
        RemovePiece remove_piece = 35;

        // turn
        StartGame start_game = 100;
        Turn turn = 101;
        SetTurn set_turn = 102;
        DiceResult dice_result = 103;
        DiceResultResources dice_result_resources = 104;

        // player info

        // player actions
    }
}

message GameMessageFromClient {
    string ga_name = 1;      // Name of game
    oneof msg {
        // turn
        StartGame start_game = 100;
        EndTurn end_turn = 101;
    }
}
